esphome:
  name: smart-plant
  # Initialize the IIC bus immediatelly after the powering the sensors
  on_boot:
    priority: 600
    then:
     - lambda: |-
          Wire.begin();
          delay(100);

external_components:
  - source:
      type: git
      url: https://github.com/velaar/esphome
      ref: dev
    components: [ waveshare_epaper, display]

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
  password: ***********

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Smart-Plant"
    password: "smartplant"

captive_portal:


i2c:
  scl: GPIO22
  sda: GPIO21
  scan: true
  id: bus_a

spi:
  clk_pin:  GPIO13
  mosi_pin: GPIO14
    
image:
  - file: "Lemon_tree_label_page_1.png"
    id: page_1_background

font:
  - file: "fonts/Audiowide.ttf"
    id: font_title
    size: 20
  - file: "fonts/Audiowide.ttf"
    id: font_subtitle
    size: 15
  - file: "fonts/Audiowide.ttf"
    id: font_parameters
    size: 15

time:
  - platform: homeassistant
    id: esptime

switch:
  - platform: gpio
    pin: GPIO16
    id: exc
    name: "Excitation switch"
    icon: "mdi:power"
    restore_mode: ALWAYS_ON  
    
    
sensor:
  # Temperature and humidity sensor
  - platform: aht10
    temperature:
      name: "Temperature"
      id: temp
      icon: "mdi:thermometer"
    humidity:
      name: "Air Humidity"
      id: hum
      icon: "mdi:water-percent"
    update_interval: 1s
    
  # Light sensor
  - platform: adc
    pin: GPIO33
    id: illum
    name: "Light"
    icon: "mdi:white-balance-sunny"
    attenuation: 11db
    unit_of_measurement: lux
    update_interval: 1s
    filters:
    - lambda: |-
        return (x / 10000.0) * 2000000.0;
        
  # Capacitive soil moisture sensor
  - platform: adc
    pin: GPIO32
    name: "Soil Moisture"
    id : soil
    icon: "mdi:cup-water"
    update_interval: 1s
    unit_of_measurement: "%"
    attenuation: 11db
    filters:
    - median:
        window_size: 7
        send_every: 3

    - calibrate_linear:
        - 1.25 -> 100.00
        - 2.8 -> 0.00
    - lambda: if (x < 1) return 0; else if (x > 100) return 100; return (x);
    accuracy_decimals: 0
    on_value:
      then:
        - component.update: my_display      

display:
  - platform: waveshare_epaper
    dc_pin: GPIO27
    cs_pin: GPIO15
    busy_pin: GPIO25
    reset_pin: GPIO26
    rotation: 270
    model: 2.90inv2
    update_interval: never
    id: my_display
    pages:
      - id: page1
        lambda: |-
          #define H_LEFT_MARGIN 4
          #define H_RIGHT_MARGIN 280
          #define H_CENTER 128 
          #define V_WEATHER 0
          #define V_CLOCK 1
          #define V_WIFI 30
          #define V_VOLTAGE 60
          #define V_BATTERY  90
          
          it.image(0, 0, id(page_1_background));
          
          // Battery
          float battery_perc = id(battery).state;
          int battery_range = battery_perc / 10 ;
          battery_range = (battery_range > 10) ? 10 : battery_range;
          battery_range = (battery_range < 0)  ?  0 : battery_range;
          
          it.printf(278, 1, id(font_icon_battery), TextAlign::TOP_LEFT, battery_icon_map[battery_range].c_str()
          );
          it.printf(278, 1, id(font_subtitle), TextAlign::TOP_RIGHT, 
          "%3.0f%%", battery_perc);
 
          
          // Clock 
          it.strftime(278, 18, id(font_subtitle), TextAlign::TOP_RIGHT, 
          "%d/%m/%y", id(esptime).now());     
          
          // Parameters
          // Drawing the marker over the gauge
          float pi = 3.141592653589793;
          float alpha = 4.71238898038469; // Defined as the gauge angle in radians (270deg)
          float beta = 2*pi - alpha;
          int radius = 22;              // Radius of the gauge in pixels
          int thick = 7;                // Size of the marker 
          
          // *** Moisture ***
          int min_range = 0; 
          int max_range = 100;
          int xc = 80;
          int yc = 50;
          
          float measured = id(soil).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          float val = (measured - min_range) / abs(max_range - min_range) * alpha;
          
          int x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          int y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          int x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          int y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          int x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          int y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0f%%", id(soil).state);  
          
          // *** Light ***
          min_range = 0; 
          max_range = 10000;
          xc = 134;
          yc = 70;
          
          measured = id(illum).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0flx", id(illum).state);  
          
          
          // *** Temperature ***
          min_range = -10; 
          max_range = 50;
          xc = 188;
          yc = 50;
          
          measured = id(temp).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0fÂ°C", id(temp).state);     
        

          // *** Humidity ***
          min_range = 20; 
          max_range = 80;
          xc = 242;
          yc = 70;
          
          measured = id(hum).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0f%%", id(hum).state);     
          

deep_sleep:
  run_duration: 10s
  sleep_duration: 3600s