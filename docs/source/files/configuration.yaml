substitutions:
  device_name: "smart-plant"
  friendly_name: "Smart Plant"
  project_name: "smart.plant"
  project_version: "1.2"
  ap_ssid: "Smart-Plant"
  ap_pwd: "smartplant"

esphome:
  name: "${device_name}"
  name_add_mac_suffix: true
  includes:
    - libraries/icon-map.h
  project:
    name: "${project_name}"
    version: "${project_version}"
  # Initialize the IIC bus immediatelly after the powering the sensors
  on_boot:
    priority: 600
    then:
     - lambda: |-
        Wire.begin();
        delay(100);

external_components:
  - source:
      type: git
      url: https://github.com/velaar/esphome
      ref: dev
    components: [ waveshare_epaper, display]

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:

# Enable Over The Air updates
ota:

#Public location of this yaml file
dashboard_import:
  package_import_url: github://JGAguado/Smart_Plant/docs/source/files/configuration.yaml
  import_full_config: false

# Enable fallback hotspot (captive portal) in case wifi connection fails
captive_portal:

esp32_improv:
  authorizer: none

improv_serial:

wifi:
  ap:
    ssid: "${ap_ssid}"
    password: "${ap_pwd}"


i2c:
  scl: GPIO22
  sda: GPIO21
  scan: false
  id: bus_a
  frequency: 100kHz

spi:
  clk_pin:  GPIO13
  mosi_pin: GPIO14
    
image:
  - file: "plant_labels/Lemon_tree_label_page_1.png"
    id: page_1_background

font:
  - file: "fonts/Audiowide.ttf"
    id: font_title
    size: 20
  - file: "fonts/Audiowide.ttf"
    id: font_subtitle
    size: 15
  - file: "fonts/Audiowide.ttf"
    id: font_parameters
    size: 15
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_icon_battery
    size: 20
    glyphs:
      - "\U000F007A" # battery-10
      - "\U000F007B" # battery-20
      - "\U000F007C" # battery-30
      - "\U000F007D" # battery-40
      - "\U000F007E" # battery-50
      - "\U000F007F" # battery-60
      - "\U000F0080" # battery-70
      - "\U000F0081" # battery-80
      - "\U000F0082" # battery-90
      - "\U000F0079" # battery
      - "\U000F0083" # battery-alert
      - "\U000F10CC" # battery-alert-variant
      - "\U000F10CD" # battery-alert-variant-outline
      - "\U000F092D" # wifi-off
      - "\U000F092E" # wifi-strength-0
      - "\U000F091F" # wifi-strength-1
      - "\U000F0922" # wifi-strength-2
      - "\U000F0925" # wifi-strength-3
      - "\U000F0928" # wifi-strength-4
      - "\U000F04E6" # sync

time:
  - platform: homeassistant
    id: esptime

switch:
  - platform: gpio
    pin: GPIO16
    id: exc
    name: "Excitation switch"
    icon: "mdi:power"
    restore_mode: ALWAYS_ON  
    
    
sensor:
  # Battery level sensor  
  - platform: adc
    pin: GPIO35
    id: VCC
    internal: true
    attenuation: 11db
    update_interval: 1s
    filters:
      - multiply: 1.796
    accuracy_decimals: 5
    unit_of_measurement: V
    
  - platform: template
    name: "Battery"
    id: battery
    unit_of_measurement: "%"
    update_interval: 1s
    lambda: |-
      float battery_perc = 100.00 * (id(VCC).state) / (1.44);
      return (battery_perc > 100.0) ? 100.0 : battery_perc ;
  # Temperature and humidity sensor
  - platform: aht10
    temperature:
      name: "${friendly_name} Temperature"
      id: temp
      icon: "mdi:thermometer"
    humidity:
      name: "${friendly_name} Air Humidity"
      id: hum
      icon: "mdi:water-percent"
    update_interval: 1s
    i2c_id: bus_a

  # Light sensor
  - platform: adc
    pin: GPIO33
    id: illum
    name: "${friendly_name} Light"
    icon: "mdi:white-balance-sunny"
    attenuation: 11db
    unit_of_measurement: lux
    update_interval: 1s
    filters:
    - lambda: |-
        return (x / 10000.0) * 2000000.0;
        
  # Capacitive soil moisture sensor
  - platform: adc
    pin: GPIO32
    name: "${friendly_name} Soil Moisture"
    id : soil
    icon: "mdi:cup-water"
    update_interval: 1s
    unit_of_measurement: "%"
    attenuation: 11db
    filters:
    - median:
        window_size: 7
        send_every: 3

    - calibrate_linear:
        - 1.25 -> 100.00
        - 2.8 -> 0.00
    - lambda: if (x < 1) return 0; else if (x > 100) return 100; return (x);
    accuracy_decimals: 0
    on_value:
      then:
        - component.update: my_display      

display:
  - platform: waveshare_epaper
    dc_pin: GPIO27
    cs_pin: GPIO15
    busy_pin: GPIO25
    reset_pin: GPIO26
    rotation: 270
    model: 2.90inv2
    update_interval: never
    id: my_display
    pages:
      - id: page1
        lambda: |-
          #define H_LEFT_MARGIN 4
          #define H_RIGHT_MARGIN 280
          #define H_CENTER 128 
          #define V_WEATHER 0
          #define V_CLOCK 1
          #define V_WIFI 30
          #define V_VOLTAGE 60
          #define V_BATTERY  90
          
          it.image(0, 0, id(page_1_background));
          
          // Battery
          float battery_perc = id(battery).state;
          int battery_range = battery_perc / 10 ;
          battery_range = (battery_range > 10) ? 10 : battery_range;
          battery_range = (battery_range < 0)  ?  0 : battery_range;
          
          it.printf(278, 1, id(font_icon_battery), TextAlign::TOP_LEFT, battery_icon_map[battery_range].c_str()
          );
          it.printf(278, 1, id(font_subtitle), TextAlign::TOP_RIGHT, 
          "%3.0f%%", battery_perc);
          
          // Date
          it.strftime(278, 18, id(font_subtitle), TextAlign::TOP_RIGHT, 
          "%H:%M %d/%m", id(esptime).now());     
          
          
          // Parameters
          // Drawing the marker over the gauge
          float pi = 3.141592653589793;
          float alpha = 4.71238898038469; // Defined as the gauge angle in radians (270deg)
          float beta = 2*pi - alpha;
          int radius = 22;              // Radius of the gauge in pixels
          int thick = 7;                // Size of the marker 
          
          // *** Moisture ***
          int min_range = 0; 
          int max_range = 100;
          int xc = 80;
          int yc = 50;
          
          float measured = id(soil).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          float val = (measured - min_range) / abs(max_range - min_range) * alpha;
          
          int x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          int y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          int x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          int y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          int x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          int y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0f%%", id(soil).state);  
          
          // *** Light ***
          min_range = 0; 
          max_range = 10000;
          xc = 134;
          yc = 70;
          
          measured = id(illum).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0flx", id(illum).state);  
          
          
          // *** Temperature ***
          min_range = -10; 
          max_range = 50;
          xc = 188;
          yc = 50;
          
          measured = id(temp).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0fÂ°C", id(temp).state);     
        

          // *** Humidity ***
          min_range = 20; 
          max_range = 80;
          xc = 242;
          yc = 70;
          
          measured = id(hum).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0f%%", id(hum).state);     
          
# # Uncomment it if you want the SmartPlant to enter into deep sleep
# deep_sleep:
#   run_duration: 10s
#   sleep_duration: 3600s