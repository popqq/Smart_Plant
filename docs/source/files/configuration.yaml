substitutions:
  device_name: "smart-plant"
  friendly_name: "Smart Plant"
  project_name: "smart.plant"
  project_version: "2.1"
  ap_ssid: "Smart-Plant"
  ap_pwd: "smartplant"

esphome:
  name: "${device_name}"
  name_add_mac_suffix: true
  includes:
    - libraries/icon-map.h
    - libraries/MAX17048.h
    - libraries/VEML7700.h
  libraries:
    - "Wire"
    - "Adafruit Unified Sensor"
    - "SPI"
    - "Adafruit BusIO"
    - "Adafruit VEML7700 Library"
  project:
    name: "${project_name}"
    version: "${project_version}"
  # Initialize the IIC bus immediatelly after the powering the sensors
  on_boot:
    priority: 600
    then:
     - lambda: |-
        Wire.begin();
        delay(100);


esp32:
  board: esp32-s2-saola-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:

# Enable Over The Air updates
ota:

#Public location of this yaml file
dashboard_import:
  package_import_url: github://JGAguado/Smart_Plant/docs/source/files/configuration.yaml
  import_full_config: false

# Enable fallback hotspot (captive portal) in case wifi connection fails
captive_portal:

improv_serial:

wifi:
  ap:
    ssid: "${ap_ssid}"
    password: "${ap_pwd}"


i2c:
  scl: GPIO34
  sda: GPIO33
  scan: false
  id: bus_a

spi:
  clk_pin:  GPIO12
  mosi_pin: GPIO11
  miso_pin: GPIO13
    
image:
  - file: "plant_labels/Lemon_tree_label_page_1.png"
    id: page_1_background

font:
  - file: "gfonts://Audiowide"
    id: font_title
    size: 20
  - file: "gfonts://Audiowide"
    id: font_subtitle
    size: 15
  - file: "gfonts://Audiowide"
    id: font_parameters
    size: 15
  - file: 'fonts/materialdesignicons-webfont.ttf'
    id: font_icon_battery
    size: 20
    glyphs:
      - "\U000F007A" # battery-10
      - "\U000F007B" # battery-20
      - "\U000F007C" # battery-30
      - "\U000F007D" # battery-40
      - "\U000F007E" # battery-50
      - "\U000F007F" # battery-60
      - "\U000F0080" # battery-70
      - "\U000F0081" # battery-80
      - "\U000F0082" # battery-90
      - "\U000F0079" # battery
      - "\U000F0083" # battery-alert
      - "\U000F10CC" # battery-alert-variant
      - "\U000F10CD" # battery-alert-variant-outline
      - "\U000F092D" # wifi-off
      - "\U000F092E" # wifi-strength-0
      - "\U000F091F" # wifi-strength-1
      - "\U000F0922" # wifi-strength-2
      - "\U000F0925" # wifi-strength-3
      - "\U000F0928" # wifi-strength-4
      - "\U000F04E6" # sync

time:
  - platform: homeassistant
    id: esptime

switch:
  - platform: gpio
    pin: GPIO4
    id: exc
    name: "Excitation switch"
    icon: "mdi:power"
    restore_mode: ALWAYS_ON  
    
    
sensor:    
  # Battery level sensor  
  - platform: custom
    lambda: |-
      auto max17048_sensor = new MAX17048Sensor();
      App.register_component(max17048_sensor);
      return {max17048_sensor->voltage_sensor, max17048_sensor->percentage_sensor};
    sensors:
      - name: "Bat. voltage"
        unit_of_measurement: V
        accuracy_decimals: 2
        id: batvoltage

      - name: "Battery"
        id: battery
        icon: "mdi:battery"
        unit_of_measurement: '%'
  # Temperature and humidity sensor
  - platform: aht10
    variant: aht20
    i2c_id: bus_a
    temperature:
      name: "Temperature"
      id: temp
      icon: "mdi:thermometer"
    humidity:
      name: "Air Humidity"
      id: hum
      icon: "mdi:water-percent"
    update_interval: 3s

  # Light sensor
  - platform: custom
    lambda: |-
      auto my_veml7700_sensor = new MyVEML7700Sensor();
      App.register_component(my_veml7700_sensor);
      return {
        my_veml7700_sensor->veml7700_lux
      };

    sensors:
      - name: "Light"
        id: light
        accuracy_decimals: 0
        unit_of_measurement: lux
        
  # Capacitive soil moisture sensor
  - platform: adc
    pin: GPIO1
    name: "Soil Moisture"
    id : soil
    icon: "mdi:cup-water"
    update_interval: 1s
    unit_of_measurement: "%"
    attenuation: 11db
    filters:
    - median:
        window_size: 5
        send_every: 5

    - calibrate_linear:
        - 1.25 -> 100.00
        - 2.8 -> 0.00
    - lambda: if (x < 1) return 0; else if (x > 100) return 100; return (x);
    accuracy_decimals: 0

display:
  - platform: waveshare_epaper
    cs_pin: GPIO10
    dc_pin: GPIO13
    busy_pin: GPIO14
    reset_pin: GPIO15
    rotation: 270
    model: 2.90inv2
    id: my_display
    update_interval: never
    full_update_every: 1
    pages: 
      - id: page1
        lambda: |-
          #define H_LEFT_MARGIN 4
          #define H_RIGHT_MARGIN 280
          #define H_CENTER 128 
          #define V_WEATHER 0
          #define V_CLOCK 1
          #define V_WIFI 30
          #define V_VOLTAGE 60
          #define V_BATTERY  90
          
          it.image(0, 0, id(page_1_background));
          
          // // Battery
          float battery_perc = id(battery).state;
          int battery_range = battery_perc / 10 ;
          battery_range = (battery_range > 10) ? 10 : battery_range;
          battery_range = (battery_range < 0)  ?  0 : battery_range;
          
          it.printf(278, 1, id(font_icon), TextAlign::TOP_LEFT, battery_icon_map[battery_range].c_str()
          );
          it.printf(278, 1, id(font_subtitle), TextAlign::TOP_RIGHT, 
          "%3.0f%%", battery_perc);
          
          // Date
          it.strftime(278, 18, id(font_subtitle), TextAlign::TOP_RIGHT, 
          "%H:%M %d/%m", id(esptime).now());     
          it.printf(278, 20, id(font_icon), TextAlign::TOP_LEFT, accessories_icon_map["Synchronize"].c_str()
          );

          // Parameters
          // Drawing the marker over the gauge
          float pi = 3.141592653589793;
          float alpha = 4.71238898038469; // Defined as the gauge angle in radians (270deg)
          float beta = 2*pi - alpha;
          int radius = 22;              // Radius of the gauge in pixels
          int thick = 7;                // Size of the marker 
          
          // *** Moisture ***
          int min_range = 0; 
          int max_range = 100;
          int xc = 80;
          int yc = 50;
          
          float measured = id(soil).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          float val = (measured - min_range) / abs(max_range - min_range) * alpha;
          
          int x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          int y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          int x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          int y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          int x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          int y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0f%%", id(soil).state);  
          
          // *** Light ***
          min_range = 0; 
          max_range = 3775;
          xc = 134;
          yc = 70;
          
          measured = id(light).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0flx", id(light).state);  
          
          
          // *** Temperature ***
          min_range = -10; 
          max_range = 50;
          xc = 188;
          yc = 50;
          
          measured = id(temp).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0fÂ°C", id(temp).state);     
        

          // *** Humidity ***
          min_range = 20; 
          max_range = 80;
          xc = 242;
          yc = 70;
          
          measured = id(hum).state;
          
          if (measured < min_range) {
            measured = min_range;
          } 
          if (measured > max_range) {
            measured = max_range;
          } 
          
          val = (measured - min_range) / abs(max_range - min_range) * alpha;        
          x0 = static_cast<int>(xc + radius + radius * cos(pi / 2 + beta / 2 + val));
          y0 = static_cast<int>(yc + radius + radius * sin(pi / 2 + beta / 2 + val));
          x1 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val + 0.1));
          y1 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val + 0.1));
          x2 = static_cast<int>(xc + radius + (radius+thick) * cos(pi / 2 + beta / 2 + val - 0.1));
          y2 = static_cast<int>(yc + radius + (radius+thick) * sin(pi / 2 + beta / 2 + val - 0.1));
          it.line(x0, y0, x1, y1);
          it.line(x1, y1, x2, y2);
          it.line(x2, y2, x0, y0);
          
          it.printf(xc + radius, yc + 1.7*radius, id(font_parameters), TextAlign::TOP_CENTER, 
          "%.0f%%", id(hum).state);      
          
# # Uncomment it if you want the SmartPlant to enter into deep sleep
# deep_sleep:
#   run_duration: 10s
#   sleep_duration: 3600s